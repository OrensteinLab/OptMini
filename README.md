# OptMini

Implementation of several algorithms from the paper *Generating minimum-density minimizers*.

## Table of Contents
- [Introduction](#introduction)
- [Prerequisites](#prerequisites)
- [Installation and Compilation](#installation-and-compilation)
- [Usage](#usage)
  - [Generating binary minimizers with optimal density](#generating-binary-minimizers-with-optimal-density)
  - [Average Density Computation](#average-density-computation)
- [Technical Notes](#technical-notes)
- [Additional Scripts](#additional-scripts)
- [Tables](#tables)
- [Contact](#contact)

## Introduction
A C++ implementation of OM-heap (with OM-UHS) for generating optimal-density minimizer orders for binary alphabets for **k ≤ 6**. This repository also implements computing average density values for **k<=4** using dynamic programming (also in C++). Additionaly, any other algorithm used in the paper is included as an interactive python notebook.


## Prerequisites
Before you begin, ensure you have the following:

- **64-bit system**: Required to run the binaries or compile OptMini.
- **C++ Compiler**: Only required if you are compiling OptMini yourself (supports C++20, e.g., `g++` version 10 or higher).



## Installation and Compilation

Precompiled binaries are available for **Ubuntu**. You can download them from the [GitHub release page](https://github.com/OrensteinLab/OptMini/releases).
Ensure that the program has execution permissions by running the following command:  
```bash
chmod +x ./OptMini
```

To ensure that the compiled Linux binaries do not depend on newer GLIBC or libstdc++ symbols (e.g., `GLIBC_2.35`, `GLIBCXX_3.4.30`), we build using GitHub Actions on **Ubuntu 22.04**. This ensures that our released executables can run on most modern Linux distributions without encountering linker errors about missing GLIBC/GLIBCXX versions.

If your system is significantly older (e.g., it has GLIBC < **2.35**), you may still need to build from source. Alternatively, you can run in a newer environment such as Docker or a more up-to-date Linux distribution.



## Usage

### Generating Binary Minimizers with Optimal Density

To generate a minimizer with optimal binary density, run:

```bash
./OptMini -routine OM-heap -w {w} -k {k}
```

Where:
- `{w}`: The window size.
- `{k}`: The k-mer size.

An example run would be:
```
./OptMini -routine OM-heap -w {192} -k {6}
```

#### Additional Parameters
- `{time_limit_minutes}`: Is a set time limit, which afterwards a lower bound for the optimal number of charged (w+k)-windows is reported (default: `60`)

### Average Density Computation
To compute the average density of all binary minimizers for specific `k<` and `w` run:

```
./OptMini -routine calc_average_dens -w {w} -k {k}
```

Where:
- `{w}`: The window size.
- `{k}`: The k-mer size.

An example run would be:

```
./OptMini -routine calc_average_dens -w 10 -k 4
```

## Technical Notes
Supported ranges:
- OM-heap: `k ≤ 6`, `w ≤ ~255 − k`
- Average density: `k ≤ 4`, `w ≤ ~200`


## ILP Scripts

To run the ILP formulation described in the paper, use the scripts provided in the `./ILP` folder. 
Before running, update your Gurobi license information in `gurobi.json`



### Running the ILP Solver

To solve the ILP for a given `(w, k)` pair, run:

```bash
python main.py -w {w} -k {k}
```

Where:
- `{w}`: The window size.  
- `{k}`: The k-mer length.

An example run would be:

```bash
python main.py -w 10 -k 4
```

### Additional Parameters

- `-sigma {σ}`: Alphabet size (default: `2`)
- `-time_limit {minutes}`: Maximum solve time in minutes (default: `1`)
- `-threads {t}`: Number of threads to use (default: half the number of logical cores)

### Version Notes
The ILP scripts were tested using:
- Python 3.9.21  
- GurobiPy 11.0.2  
- NumPy 1.26.4  
- Pandas 2.1.2


## Additional Scripts
We include the scripts used in the paper inside the `./scripts` folder.  
Mainly, it contains:

1. OM-phase (`OM-phase.ipynb`, TO BE ADDED)
2. Script to measure the density of the orders (`calc_density.ipynb`)
3. Script to encode a minimizer string into the [GreedyMini](https://github.com/OrensteinLab/GreedyMini) format (`encode_opt_order.ipynb`)
4. DFS version of calculating the average density of binary minimizers (`average_density_dfs.ipynb`)
6. The code used to generate the paper’s plots (`plots.ipynb`), alongside the files needed for plotting.

### Version Notes
These scripts were tested using
- Python 3.11.4 
- NumPy 1.24.3  
- Pandas 2.3.0
- Matplotlib 3.10.3

## Tables
`Table-1.csv` contains density factors used in the plots of the paper.
`Table-2.xlsx` contains minimizer orders and the ranges they are optimal for. If an order generated by OM-heap was already optimal for a larger window size (w < w'), we reused it instead of the one generated for w'.

## Contact
In case of issues with OptMini, you may contact us at tziony.i@gmail.com.



